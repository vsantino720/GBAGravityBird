#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/playerg.h"
#include "images/playergu.h"
#include "images/welcome.h"
#include "images/background.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  //Global variable for player acceleration and velocity
  int acceleration = 1;
  int velocity = 0;
  int frequency = 5; //Augments acceleration to simulate decimal values.
  int gameSpeed = 1;
  int score = 0;
  int highscore = 0;


  //Current and Previous Player Structs
  struct player cp, pp;
  struct pillar cpillar[MAX_PILLARS], ppillar[MAX_PILLARS];

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    pp = cp;
    for (int i = 0; i < MAX_PILLARS; i++) {
        ppillar[i] = cpillar[i];
    }

    switch (state) {
      case START:
          //Initialize Player
          cp.row = 80;
          cp.col = 110;
          cp.width = PLAYERG_WIDTH;
          cp.height = PLAYERG_HEIGHT;
          cp.image = playerg;
          //Fill Pillars array
          for (int i = 0; i < MAX_PILLARS; i++) {
              cpillar[i].length = randint(40, 100);
              cpillar[i].width = 10;
              cpillar[i].color = RED;
              if (i) {
                  cpillar[i].col = cpillar[i - 1].col + randint(30, 61);
              }
              else {
                  cpillar[0].col = WIDTH - cpillar[0].width;
              }
              if (i % 2) {
                  cpillar[i].origin = 1;
              }
              else {
                  cpillar[i].origin = 0;
              }
          }
          //Reinitialize values
          score = 0;
          acceleration = 1;
          velocity = 0;
          gameSpeed = 1;
          frequency = 5;
          char highscoreString[30];
          sprintf(highscoreString, "Highscore: %d", highscore);

          pp = cp;
          for (int i = 0; i < MAX_PILLARS; i++) {
              ppillar[i] = cpillar[i];
          }

          waitForVBlank();
          drawFullScreenImageDMA(welcome);
          drawCenteredString(145, 120, 10, 10, highscoreString, YELLOW);
          if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
              drawFullScreenImageDMA(background);
              state = PLAY;
          }
        break;
      case PLAY:
          //Check for player input 
          if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
              acceleration = acceleration * -1;
              if (acceleration < 0) {
                  cp.image = playergu;
              }
              else {
                  cp.image = playerg;
              }
          }
          if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
              state = START;
          }
          if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && (cp.col < MAX_COLUMN)) {
              cp.col = cp.col + 1;
          }
          if (KEY_DOWN(BUTTON_LEFT, currentButtons) && (cp.col > MIN_COLUMN)) {
              cp.col = cp.col - 1;
          }
          //Calculate new velocity
          if (!(vBlankCounter % frequency)) {
              velocity = velocity + acceleration;
          }
          //Update position
          cp.row = cp.row + velocity;
          for (int i = 0; i < MAX_PILLARS; i++) {
              cpillar[i].col = cpillar[i].col - gameSpeed;

          }
          //Check for collisions
          if (cp.row <= CEILING_ROW) {
              cp.row = CEILING_ROW;
              velocity = 0;
          }
          if ((cp.row + cp.height) >= FLOOR_ROW) {
              cp.row = FLOOR_ROW - cp.height;
              velocity = 0;
          }
          for (int i = 0; i < MAX_PILLARS; i++) {
              if ((cpillar[i].col < 0)) {
                  cpillar[i].width = cpillar[i].width + cpillar[i].col;
                  cpillar[i].col = 0;
                  if (cpillar[i].width <= 0) {
                      cpillar[i].width = 10;
                      cpillar[i].length = randint(40, 70 + 30 / gameSpeed);
                      cpillar[i].col = WIDTH - cpillar[i].width;
                  }
              }
          }

          for (int i = 0; i < MAX_PILLARS; i++) {
              if (!cpillar[i].origin) {
                  if ((cp.col + cp.width) >= cpillar[i].col && cp.row <= cpillar[i].length
                      && cp.col <= cpillar[i].col + cpillar[i].width) {
                      state = LOSE;
                  }
              }
              else {
                  if ((cp.col + cp.width) >= cpillar[i].col && cp.row >= HEIGHT - cpillar[i].length
                      && cp.col <= cpillar[i].col + cpillar[i].width) {
                      state = LOSE;
                  }
              }
          }

          if (!(vBlankCounter % 60)) {
              score++;
              if (score > highscore) {
                  highscore = score;
              }
              if (score == 30) {
                  gameSpeed = 2;
                  frequency = 3;
              }
          }
          //Create scorestring
          char scoreString[20];
          sprintf(scoreString, "Score: %d", score);

          waitForVBlank();
          //Erase old player
          //drawRectDMA(pp.row, pp.col, pp.width, pp.height, BLACK);
          drawFullScreenPartialDMA(pp.row, pp.col, pp.width, pp.height, background);
          //Draw new player
          drawImageDMA(cp.row, cp.col, cp.width, cp.height, cp.image);
          //Erase old score
          //drawRectDMA(5, 5, 80, 10, BLACK);
          drawFullScreenPartialDMA(5, 5, 80, 10, background);
          //Erase old Pillars, Draw new
          for (int i = 0; i < MAX_PILLARS; i++) {
              if (ppillar[i].col <= WIDTH - ppillar[i].width)
              erasePillar(&ppillar[i], background);
              if (cpillar[i].col <= WIDTH - cpillar[i].width)
              drawPillar(&cpillar[i]);
          }
          //Draw Score
          drawString(5, 5, scoreString, YELLOW);
          break;

      case LOSE:
          sprintf(highscoreString, "Highscore: %d", highscore);
          waitForVBlank();
          drawCenteredString(60, 120, 10, 10, "GAME OVER", YELLOW);
          drawCenteredString(80, 120, 10, 10, "Press Select", YELLOW);
          drawCenteredString(100, 120, 10, 10, highscoreString, YELLOW);

          if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
              state = START;
          }
        // state = ?
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used
  return 0;
}

